<?php
namespace Service;

abstract class Model extends Collection
{
	public static $domain;
	static public $method, $ranges = array(), $options = array();

	/**
	 * Processes a request from the rest server and dispatches the request to
	 * the appropriate method
	 * @param	int		$id		a primary key used by the delegate method
	 * @param	string	$method	the HTTP request method
	 * @param	array	$data	an array of data used by the delegate method
	 * @return	array			the response generated by the delegate method
	 */

	public static function init( $method = 'GET', $params = array(), $data = array() )
	{
		global $config, $page;

		// check if a range (subset) is requested...
		if( ! empty( $_SERVER['HTTP_RANGE'] ) )
			static::$ranges = $_SERVER['HTTP_RANGE'];

		// ...and look for any modifiers/options
		if( ! empty( $_SERVER['HTTP_PRAGMA'] ) )
			static::$options = static::tokenize( $_SERVER['HTTP_PRAGMA'] );

		// if domain is not set, default to collect. (without a domain, system
		// wouldn't know how to pull a single entity anyway)
		if( ! empty( static::$domain ) )
		{
			$domain = static::$domain;
			// pull the primary key(s) and diff against page params
			// if any key is returned, assume it's a collection
			$keys = (array) $domain::getKeys( 'primary' );

			// swap fields (values) for keys
			$keys = array_flip( $keys );

			// flip the boolean twice (array() [falsy value] -> true -> false)
			// or (array(some_key) [truish value] -> false -> true
			$collection = !! array_diff_key( $keys, $params );
			unset( $keys );
		}

		// collection is the safest default. collections can return a single
		// result, other methods can't return a collection
		else
			$collection = true;



		try
		{
			if( $method == 'GET' )
			{
				return ( $collection
					? static::getCollection( array_merge( $data, $params ) )
					: static::get( $params, $data ) );
			}

			else if( $method == 'POST' )
			{
				return ( $collection
					? static::postCollection( array_merge( $data, $params ) )
					: static::post( array_merge( $data, $params ) ) );
			}

			else if( $method == 'PUT' && $domain )
				return static::put( $params, $data );

			else if( $method == 'DELETE' && $domain )
				return static::delete( $params );

			else
				throw new RESTException(
					"Method $method not allowed at {$page->request}",
					$config->HTTP_METHOD_NOT_ALLOWED );

		}
		catch( RESTException $e )
		{
			$return = array(
				'success'	=>	'false',
				'status'	=>	$e->getCode(),
				'message'	=>	$e->getMessage()
			);

			// send error/debug info as part of response if in a DEV
			// environment, otherwise write to error logs
			if( $config->DEV )
			{
				$return['error'] = $e->getError();
				$return['debug'] = $e->getDebug();
			}

			// log errors, no matter what environment
			$class = get_called_class();
			error_log( "$class request failed: {$page->request}" );
			error_log( "$class error: " . $e->getError() );
			error_log( "$class debug: " . $e->getDebug() );

			return $return;
		}
	} // end method init


	public static function post( $post )
	{
		global $config;

		try
		{
			$domain = static::$domain;
			$obj = new $domain();
			$obj->update( $post );

			// true to force insert
			$obj->save( true );

			return static::respond( $obj, $config->HTTP_OK );
		}
		catch( \Exception $e )
		{
			throw new RESTException( 'An error occured',
				$config->HTTP_INTERNAL_SERVER_ERROR, $e->getCode(),
				$e->getMessage() );
		}

		return static::respond( $obj, $config->HTTP_CREATED );
	}

	public static function get( $id, $get )
	{
		global $config;

		try
		{
			$domain = static::$domain;
			$obj = new $domain( $id );
			return static::respond( $obj, $config->HTTP_OK );
		}
		catch( \Exception $e )
		{
			throw new RESTException( 'An error occured',
				$config->HTTP_INTERNAL_SERVER_ERROR, $e->getCode(),
				$e->getMessage() );
		}
	}

	public static function put( $params, $put )
	{
		global $config;

		try
		{
			$domain = static::$domain;

			$obj = new $domain( $params );
			$obj->update( $put );
			$obj->save();
			return static::respond( $obj, $config->HTTP_OK );
		}
		catch( \Exception $e )
		{
			throw new RESTException( 'An error occured',
				$config->HTTP_INTERNAL_SERVER_ERROR, $e->getCode(),
				$e->getMessage() );
		}
	}

	public static function delete( $params )
	{
		global $config;

		try
		{
			$domain = static::$domain;
			$obj = new $domain( $params );
			$obj->delete();
			return static::respond( '', $config->HTTP_OK );
		}
		catch( \Exception $e )
		{
			throw new RESTException( 'An error occured',
				$config->HTTP_INTERNAL_SERVER_ERROR, $e->getCode(),
				$e->getMessage() );
		}
	}


	/**
	 * Parse a range string into usable values
	 * @param	string	$values	an arbitrary string of ranges
	 * ex: 104-109,143; -100 (0 - 100); 100- (>=100)
	 */

	public static function parseRange( $values )
	{
		$ranges = explode( ',', $values );
		$ret = array();
		foreach( $ranges as $key => $range )
		{
			// check if a large range exists (i.e., 1-100)
			if( strpos($range, '-') !== false )
			{
				$range = explode( '-', $range );
				// don't need to check if $range[0] exists
				// if range is "-40" or similar (which means 0-40)
				// $range[0] is null and it starts from 0
				$range = range( $range[0], $range[1] );
				$ret = array_merge( $ret, $range );
			}
			else
			{
				$ret[] = intval($range);
			}
		}

		// gc
		unset( $ranges, $values, $key, $range);
		return $ret;
	}


	/**
	 * Parse a string into usable options/ranges
	 * @param	string	$option	a string to parse for options
	 * @return	array
	 */

	public static function tokenize( $option )
	{
		// split string into chunks at semi-colon or whitespace chars
		$option = preg_split( '/;\s*/', $option );
		$return = array();

		foreach( $option as $opt )
		{
			$opt = explode( '=', $opt );
			if( ! empty( $opt[0] ) )
				$return[$opt[0]] = ( ! empty( $opt[1] ) ? $opt[1] : true );
		}
		// gc
		unset( $option, $opt );

		return $return;
	} // end method tokenize


	public static function respond( $data, $status = 200, $success = 'true' )
	{
		return array(
			'success' => $success,
			'status' => $status,
			'data' => $data
		);
	}
}
?>